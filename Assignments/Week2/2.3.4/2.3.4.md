# The "Gherkin-Only" Config

# The Task:
 Create a specialized configuration for your local AI that forces it to behave like a BDD (Behavior Driven Development) expert.
Action:
Update your Personal Copilot Documentation Prompt with the "Senior QA" rules above.
Open microservices/cart-service/src/service.ts.
Highlight the clearCart function.
Ask the local extension: "Test this."
Success Criteria: The output must automatically be in Gherkin syntax (Given user has items... When they clear...) without you asking for "Gherkin" in the chat.
Submission: Share a screenshot of your System Prompt configuration and the resulting Gherkin output in #daily-challenge.
Professional Note: Using a Personal Copilot extension bridges the gap between the privacy of Ollama and the convenience of an IDE. It allows you to "Shift Left" on security compliance while keeping the developer experience smooth.

Note I could not get Test This to work so generated manulally using the Ask and documentation prefix 

# Personal Copilot Doc Config

To improve this prompt, it helps to lean into the "Quality as a Consultant" mindset by explicitly defining the output structure and the "Risk" factors you want to address.

Here is a refined version designed to be more precise, ensuring you get high-coverage Gherkin without the usual AI "fluff."

Improved Prompt
Role: You are a Senior QA Automation Architect specializing in BDD and Risk-Based Testing.

Objective: Transform the provided code snippet into a robust suite of Gherkin test scenarios.

Required Analysis Pillars: Before generating scenarios, internally evaluate the code for:

Boundary Conditions: Max/min values, nulls, and empty states.

Failure Modes: Timeout handling, dependency failures, and invalid inputs.

State Management: Side effects and persistence.

Strict Output Rules:

Syntax: Output must be in valid Gherkin syntax (Feature, Scenario, Given, When, Then).

Actionable Steps: Steps must be concrete (e.g., "Enter '123' into the Zip Code field" rather than "Enter invalid data").

Categorization: Include scenarios for Positive Path, Negative/Error Path, and Edge Cases.

Constraint: No conversational filler, no explanations of your logic, and no "Here are your tests." Output only the .feature file content.


# Output using 
```gherkin
Feature: Cart Service Functionality

  Scenario: Add valid product to cart
    Given a user with ID "user1"
    And a valid product with ID "1" exists
    When the user adds 1 quantity of product "1" to the cart
    Then the cart should contain the product with ID "1" and quantity 1
    And the total amount should be 10.99

  Scenario: Update quantity when product already in cart
    Given a user with ID "user1"
    And a valid product with ID "1" exists
    When the user adds 1 quantity of product "1" to the cart
    And the user adds 2 more quantities of product "1" to the cart
    Then the cart should contain the product with ID "1" and quantity 3
    And the total amount should be 32.97

  Scenario: Update cart item quantity and recalculate total
    Given a user with ID "user1"
    And a valid product with ID "1" exists
    When the user adds 2 quantities of product "1" to the cart
    And the user updates the quantity of product "1" to 5
    Then the cart should contain the product with ID "1" and quantity 5
    And the total amount should be 54.95

  Scenario: Remove item when quantity is updated to 0
    Given a user with ID "user1"
    And a valid product with ID "1" exists
    When the user adds 2 quantities of product "1" to the cart
    And the user updates the quantity of product "1" to 0
    Then the cart should be empty
    And the total amount should be 0.00

  Scenario: Handle 3 items at 10.99 with correct rounding
    Given a user with ID "user1"
    And a valid product with ID "1" and price 10.99 exists
    When the user adds 3 quantities of product "1" to the cart
    Then the total amount should be 32.97
    And the total amount formatted to 2 decimal places should be 32.97

  Scenario: Round total to 2 decimal places for multiple items
    Given a user with ID "user1"
    And a valid product with ID "2" and price 25.50 exists
    When the user adds 3 quantities of product "2" to the cart
    Then the total amount should be 76.50
    And the number of decimal places should be less than or equal to 2

  Scenario: Maintain decimal precision across multiple operations
    Given a user with ID "user1"
    And valid products with IDs "1" and "2" exist
    When the user adds 1 quantity of product "1" to the cart
    And the user adds 1 quantity of product "2" to the cart
    Then the total amount should be 36.49 when rounded to 2 decimal places

  Scenario: Completely remove an item from the items array
    Given a user with ID "user1"
    And valid products with IDs "1" and "2" exist
    When the user adds 2 quantities of product "1" to the cart
    And the user adds 1 quantity of product "2" to the cart
    And the user removes product "1" from the cart
    Then the cart should contain only product "2"
    And the cart should not contain product "1"

  Scenario: Preserve remaining items when one is removed
    Given a user with ID "user1"
    And valid products with IDs "1" and "2" exist
    When the user adds 2 quantities of product "1" to the cart
    And the user adds 3 quantities of product "2" to the cart
    And the user removes product "1" from the cart
    Then the cart should contain only product "2" with quantity 3
    And the remaining item should have the correct price and name

  Scenario: Update totalItems to reflect only remaining item quantities
    Given a user with ID "user1"
    And valid products with IDs "1" and "2" exist
    When the user adds 5 quantities of product "1" to the cart
    And the user adds 3 quantities of product "2" to the cart
    And the user removes product "1" from the cart
    Then the total items count should be 3

  Scenario: Set totalItems to 0 when last item is removed
    Given a user with ID "user1"
    And a valid product with ID "1" exists
    When the user adds 5 quantities of product "1" to the cart
    And the user removes product "1" from the cart
    Then the total items count should be 0

  Scenario: Recalculate totalAmount correctly after removal
    Given a user with ID "user1"
    And valid products with IDs "1" and "2" exist
    When the user adds 2 quantities of product "1" to the cart
    And the user adds 1 quantity of product "2" to the cart
    And the user removes product "1" from the cart
    Then the total amount should be 25.50

  Scenario: Apply formula totalAmount = Σ(price × quantity) for remaining items
    Given a user with ID "user1"
    And valid products with IDs "1", "2", and "3" exist
    When the user adds 1 quantity of product "1" to the cart
    And the user adds 2 quantities of product "2" to the cart
    And the user adds 1 quantity of product "3" to the cart
    And the user removes product "2" from the cart
    Then the total amount should be 110.98
    And the calculated total should match the cart total amount

  Scenario: Set totalAmount to 0 when last item is removed
    Given a user with ID "user1"
    And a valid product with ID "1" exists
    When the user adds 3 quantities of product "1" to the cart
    And the user removes product "1" from the cart
    Then the total amount should be 0

  Scenario: Maintain 2 decimal precision after removal
    Given a user with ID "user1"
    And valid products with IDs "1" and "2" exist
    When the user adds 3 quantities of product "1" to the cart
    And the user adds 2 quantities of product "2" to the cart
    And the user removes product "1" from the cart
    Then the total amount should be 51.00
    And the number of decimal places should be less than or equal to 2

  Scenario: Decrement items array length by exactly one
    Given a user with ID "user1"
    And valid products with IDs "1" and "2" exist
    When the user adds 1 quantity of product "1" to the cart
    And the user adds 1 quantity of product "2" to the cart
    And the user removes product "1" from the cart
    Then the items array length should decrease by exactly 1

  Scenario: Maintain item order and data integrity for remaining items
    Given a user with ID "user1"
    And valid products with IDs "1", "2", and "3" exist
    When the user adds 2 quantities of product "1" to the cart
    And the user adds 3 quantities of product "2" to the cart
    And the user adds 1 quantity of product "3" to the cart
    And the user removes product "2" from the cart
    Then the remaining items should be in order "1" and "3"
    And each remaining item should have correct properties

  Scenario: Handle removal of non-existent item gracefully
    Given a user with ID "user1"
    And a valid product with ID "1" exists
    When the user adds 2 quantities of product "1" to the cart
    And the user removes product "1" from the cart
    And the user tries to remove non-existent product "999" from the cart
    Then the cart should remain empty
    And the total items count should be 0
    And the total amount should be 0

  Scenario: Update the updatedAt timestamp on removal
    Given a user with ID "user1"
    And a valid product with ID "1" exists
    When the user adds 1 quantity of product "1" to the cart
    And the user removes product "1" from the cart
    Then the updatedAt timestamp should be updated

  Scenario: Persist cart state after removal
    Given a user with ID "user1"
    And valid products with IDs "1" and "2" exist
    When the user adds 2 quantities of product "1" to the cart
    And the user adds 1 quantity of product "2" to the cart
    And the user removes product "1" from the cart
    Then the cart state should be persisted with only product "2"
    And subsequent retrieval should show the same cart state


```